<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Authenticating the Janus API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Authenticating the Janus API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>By default no authentication is involved when using the Janus API. This means that the API is completely open, and that everybody can talk to Janus and its plugins and set up media connections. There are times, though, where limiting access to Janus may be desirable, e.g., when you want to prevent unauthorized users to join a service you created, or when you wrap the Janus API in your server and you want your application to be the only one to be able to interact with Janus from a messaging perspective.</p>
<p>There are a couple of ways to authenticate requests in Janus:</p>
<ul>
<li>using a <a class="el" href="auth.html#token">Stored token based authentication mechanism</a> (useful for web users);</li>
<li>using a <a class="el" href="auth.html#signed">HMAC-Signed token authentication</a> (useful for web users);</li>
<li>using a <a class="el" href="auth.html#secret">Shared static secret</a> (useful when wrapping the Janus API).</li>
</ul>
<h1><a class="anchor" id="token"></a>
Stored token based authentication mechanism</h1>
<p>The token based authentication mechanism expects all users to provide, in each request, a <code>token</code> string attribute: if this token is known to Janus, the request will be accepted, otherwise it will be rejected as an <code>unauthorized</code> response. Configuring the token based authentication mechanism is easy enough: you can do that either via the command line (<code>-A</code> or <code>&ndash;token-auth</code> ) or in the <code>janus.jcfg</code> configuration (<code>token_auth</code> value in the <code>general</code> section).</p>
<p>These tokens are completely opaque to Janus, meaning they can be pretty much anything that you want. Janus does not do any form of authorization/authentication itself: it's up to you to provide it with valid tokens users can use, e.g., as part of your server-side application handling users. You can add and remove tokens dynamically using the <a class="el" href="admin.html">Admin/Monitor API</a>, which means you will need to enable it if you want to use tokens, or otherwise all requests will fail (Janus will never have a valid token, so all requests will be rejected).</p>
<p>You add tokens using the <code>add_token</code> admin request, while you remove them using <code>remove_token</code>. You can also limit the scope of tokens to specific plugins, by passing a list of plugins to <code>add_token</code> or modifying the token properties via <code>allow_token</code> and <code>disallow_token</code>. By default (<code>add_token</code> without any plugin specified) Janus assumes a new token is allowed to access all plugins. A list of all the existing tokens can be retrieved with a <code>list_tokens</code> request.</p>
<p>Here are a couple of examples of how you can use the requests:</p>
<pre class="fragment">{
    "janus" : "add_token",
    "token": "a1b2c3d4",
    "transaction" : "sBJNyUhH6Vc6",
    "admin_secret": "adminpassword"
}
</pre><p>This adds a new token (a1b2c3d4) that is allowed to access all the plugins in Janus (no limitation provided in <code>add_token</code> ). To create a new token and limit the scope to a few selected plugins, you can use this other syntax instead (notice the extra <code>plugins</code> array):</p>
<pre class="fragment">{
    "janus" : "add_token",
    "token": "a1b2c3d4",
    "plugins": [
        "janus.plugin.streaming",
        "janus.plugin.videoroom"
    ],
    "transaction" : "sBJNyUhH6Vc6",
    "admin_secret": "adminpassword"
}
</pre><p>In this other example, we're creating a new token, and also telling Janus that the only plugins a user with this token can access are the Streaming and Videoroom plugins. An attempt to attach to a different plugin (e.g., EchoTest) will result in an error.</p>
<p>You can change the permissions a token has with respect to plugin access at any time. In the following example, we add a new plugin to the permissions for an existing token:</p>
<pre class="fragment">{
    "janus" : "allow_token",
    "token": "a1b2c3d4",
    "plugins": [
        "janus.plugin.echotest"
    ],
    "transaction" : "sBJNyUhH6Vc6",
    "admin_secret": "adminpassword"
}
</pre><p>This way, the provided token is now also allowed to access the EchoTest plugin. To remove a permission, the syntax is this one instead:</p>
<pre class="fragment">{
    "janus" : "disallow_token",
    "token": "a1b2c3d4",
    "plugins": [
        "janus.plugin.videoroom"
    ],
    "transaction" : "sBJNyUhH6Vc6",
    "admin_secret": "adminpassword"
}
</pre><p>To retrieve a list of all the valid tokens Janus is aware of, together with the plugins each of them is allowed to access, a <code>list_tokens</code> request can be used:</p>
<pre class="fragment">{
    "janus" : "list_tokens",
    "transaction" : "sBJNyUhH6Vc6",
    "admin_secret": "adminpassword"
}
</pre><p>Finally, you can get rid of a token using a <code>remove_token</code> request:</p>
<pre class="fragment">{
    "janus" : "remove_token",
    "token": "a1b2c3d4",
    "transaction" : "sBJNyUhH6Vc6",
    "admin_secret": "adminpassword"
}
</pre><p>As anticipated, with the token based mechanism enabled, all users will need to provide a valid token as part of their requests. This is done by adding a <code>token</code> attribute to the request root, e.g.:</p>
<pre class="fragment">{
    "janus" : "create",
    "transaction" : "sBJNyUhH6Vc6",
    "token": "usertoken"
}
</pre><p>The same applies for the long poll GET messages as well, which will need to contain the <code>token</code> as a query string parameter.</p>
<p>A valid token will mean the request will be accepted and processed normally. A missing or invalid token, instead, will result in an error being returned:</p>
<pre class="fragment">{
    "janus" : "error",
    "transaction" : "sBJNyUhH6Vc6",
    "error" : {
        "code" : 403,
        "reason" : "Unauthorized request (wrong or missing secret/token)"
    }
}
</pre><p>An attempt to use a valid token to attach to a plugin it is not allowed to access, instead, will result in a different error:</p>
<pre class="fragment">{
    "janus" : "error",
    "transaction" : "sBJNyUhH6Vc6",
    "error" : {
        "code" : 405,
        "reason" : "Provided token can't access plugin 'janus.plugin.echotest'"
    }
}
</pre><h1><a class="anchor" id="signed"></a>
HMAC-Signed token authentication</h1>
<div class="well"><b>NOTE WELL:</b> At the time of writing, HMAC-Signed tokens are ONLY available for the VideoRoom plugin. If you need authentication for other plugins, you should use the <a class="el" href="auth.html#token">Stored token based authentication mechanism</a> instead.</div><p>Simple token based authentication requires the application host to continuously update the Janus instance on permission changes. Since Janus stores the tokens in memory, it can be problematic to guarantee the permissions of a dynamic application stay in sync with Janus.</p>
<p>This problem can be solved by using a type of nonce / lease system to let the application server generate automatically expiring tokens without requiring direct communication with or any data storage in Janus.</p>
<p>You can use the HMAC signed token mechanism by enabling token authentication in general, as above (<code>-A</code> or <code>&ndash;token-auth</code>) and specifying an encryption secret using <code>&ndash;token-auth-secret</code>. The same can be accomplished using <code>token_auth</code> and <code>token_auth_secret</code> in the <code>general</code> section of <code>janus.jcfg</code>.</p>
<p>With Signed token support enabled, dynamic token creation via the <a class="el" href="admin.html">Admin/Monitor API</a> is not supported. Instead, Janus will look for tokens with a format like:</p>
<pre class="fragment">&lt;timestamp&gt;,janus,&lt;plugin1&gt;[,plugin2...]:&lt;signature&gt;
</pre><p>Where <code>timestamp</code> is a UNIX timestamp (seconds since 0:00 UTC, 1.1.1970) that marks the point in time at which the token expires; <code>plugin1</code> etc. are the <code>bundle</code> names of plugins (such as <code>janus.plugin.videoroom</code>); and <code>signature</code> is the base64-encoded HMAC-SHA1 signature of the expiry timestamp in ASCII format, hashed using the <code>&ndash;token-auth-secret</code> as a key.</p>
<p>The following function can be used to sign tokens using the node.js crypto library:</p>
<pre class="fragment">const crypto = require('crypto');
function getJanusToken(realm, data = [], timeout = 24 * 60 * 60) =&gt; {
  const expiry = Math.floor(Date.now() / 1000) + timeout;

  const strdata = [expiry.toString(), realm, ...data].join(',');
  const hmac = crypto.createHmac('sha1', secret);
  hmac.setEncoding('base64');
  hmac.write(strdata);
  hmac.end();

  return [strdata, hmac.read()].join(':');
};

const token = getJanusToken('janus', ['janus.plugin.videoroom']),
</pre><p>The <code>janus</code> parameter here is the <code>realm</code> of the token. For authenticating the Janus API it should always be set to <code>janus</code>.</p>
<p>When Janus encounters a token, it will:</p>
<ul>
<li>verify that the timestamp has not passed</li>
<li>verify that the signature matches the timestamp</li>
<li>if the request requires access to a plugin, verify that the signature allows access</li>
</ul>
<p>Since the auth secret should never leave the application side, a signature like this can only be generated by the application server, which needs to be configured using the same secret.</p>
<p>Please note that tokens of this sort cannot be revoked after being signed and passed to the client. Instead of signing tokens with late expirys, it is recommended to use tokens with shorter durations and generate and transition to a new token within the expiry time of every last token when the lease time is unknown and security is critical.</p>
<h1><a class="anchor" id="secret"></a>
Shared static secret</h1>
<p>Several deployers showed an interest in wrapping the Janus API on their server side: this allows them to keep the interaction with their users the way it was before, while still benefiting from the features Janus provides. This is an easy enough step, as it just needs developers to relay the involved SDP, and implementing the Janus API messages to handle the logic.</p>
<p>That said, since in this case Janus would be contacted, through the API, just by a limited number of applications (e.g., application servers made in node.js, Ruby, Java Servlets or whatever) and not random browsers, it is reasonable to involve a mechanism to control who is allowed to contact and control it. The previous section described how you can exploit a token based mechanism for authenticating requests, but since in this case you only need a single application, or a limited set of them, to be able to talk to Janus, it's worthwhile to resort to something simpler and more static. To allow for that, Janus also exposes a shared API secret mechanism: that is, you configure Janus with a string applications need to present when sending requests, and if they don't, Janus rejects them with an <code>unauthorized</code> message.</p>
<p>Configuring the API secret mechanism is easy enough: you can do that either via the command line (<code>-a</code> or <code>&ndash;apisecret</code> ) or in the <code>janus.jcfg</code> configuration (<code>api_secret</code> value in the <code>general</code> section). When enabled, all requests addressed to that Janus instance <b>MUST</b> also contain an <code>apisecret</code> field in the Janus message headers. For instance, this message presented above would fail:</p>
<pre class="fragment">{
    "janus" : "create",
    "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><pre class="fragment">{
    "janus" : "error",
    "transaction" : "&lt;same as request&gt;"
    "error" : {
        "code" : 403,
        "reason" : "Unauthorized request (wrong or missing secret/token)"
    }
}
</pre><p>For a successful transaction, the message would have to look like this:</p>
<pre class="fragment">{
    "janus" : "create",
    "apisecret" : "&lt;API secret configured in Janus&gt;",
    "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><p>The same applies for the long poll GET messages as well, which will need to contain the <code>apisecret</code> as a query string parameter. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
